package com.dse.guifx_v3.helps;

import auto_testcase_generation.testdatagen.TestcaseExecution;
import com.dse.config.FunctionConfig;
import com.dse.config.IFunctionConfig;
import com.dse.coverage.AbstractCoverageManager;
import com.dse.coverage.CoverageDataObject;
import com.dse.environment.object.EnviroCoverageTypeNode;
import com.dse.guifx_v3.controllers.TestCasesExecutionTabController;
import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
import com.dse.guifx_v3.objects.TestCaseExecutionDataNode;
import com.dse.guifx_v3.objects.TestCasesTreeItem;
import com.dse.parser.object.ICommonFunctionNode;
import com.dse.testcase_manager.TestCase;
import com.dse.testcase_manager.TestCaseManager;
import com.dse.thread.AbstractAkaTask;
import com.dse.util.AkaLogger;
import com.dse.util.Utils;
import javafx.application.Platform;
import javafx.collections.ObservableList;

import java.util.ArrayList;
import java.util.List;

public class AutoGeneratedTestCaseExecTask extends AbstractAkaTask<TestCase> {

    private final static AkaLogger logger = AkaLogger.get(AutoGeneratedTestCaseExecTask.class);
    private TestCase testCase;
    private ICommonFunctionNode functionNode;
    private int iteration;
    private TestcaseExecution executor;
    private String additionalHeaders;
    private List<AutoGeneratedTestCaseExecTask> execTasks;

    public AutoGeneratedTestCaseExecTask(int iteration, TestcaseExecution executor, TestCase testCase,
                                         List<AutoGeneratedTestCaseExecTask> execTasks) {
        this.testCase = testCase;
        this.functionNode = testCase.getRootDataNode().getFunctionNode();
        this.executor = executor;
        this.iteration = iteration;
        this.execTasks = execTasks;
    }

    public TestCase getTestCase() {
        return testCase;
    }

    @Override
    protected TestCase call() throws Exception {
        try {
            if (testCase == null) {
                return null;
            }

            testCase.setStatus(TestCase.STATUS_EXECUTING);
            refreshNavigatorTree();

            testCase.setAdditionalHeaders(additionalHeaders);

            String coverage = Environment.getInstance().getTypeofCoverage();

            // add and initialize corresponding TestCaseExecutionDataNode
            TCExecutionDetailLogger.addTestCase(functionNode, testCase);
            TestCaseExecutionDataNode executionDataNode = TCExecutionDetailLogger.getExecutionDataNodeByTestCase(testCase);
            TCExecutionDetailLogger.logDetailOfTestCase(testCase, "Name: " + testCase.getName());
            String value = testCase.getRootDataNode().getRoot().getInputForGoogleTest();
            TCExecutionDetailLogger.logDetailOfTestCase(testCase, "Value: " + value);
            executionDataNode.setValue(value);

            // Execute random values
            executor.setTestCase(testCase);
            executor.execute();

            // export highlighted source code and coverage to file
            AbstractCoverageManager.exportCoveragesOfTestCaseToFile(testCase, coverage);

            // save test case to file
            testCase.setPathDefault();
            TestCaseManager.exportBasicTestCaseToFile(testCase);
            logger.debug("[" + Thread.currentThread().getName()+"] "+ "Save the testcase " + testCase.getName() + " to file " + testCase.getPath());

            // read coverage information from file to display on GUI
            List<TestCase> testcases = new ArrayList<>();
            testcases.add(testCase);

            switch (coverage) {
                case EnviroCoverageTypeNode.STATEMENT:
                case EnviroCoverageTypeNode.BRANCH:
                case EnviroCoverageTypeNode.BASIS_PATH:
                case EnviroCoverageTypeNode.MCDC: {
                    CoverageDataObject coverageData = AbstractCoverageManager
                            .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, coverage);
                    double cov = Utils.round(coverageData.getVisited() * 1.0f / coverageData.getTotal() * 100, 4);
                    String msg = coverage + " cov: " + cov + "%";
                    TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                    executionDataNode.setCoverage(msg);
                    break;
                }
                case EnviroCoverageTypeNode.STATEMENT_AND_BRANCH: {
                    String msg = "";
                    // stm cov
                    CoverageDataObject stmCovData = AbstractCoverageManager
                            .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.STATEMENT);
                    double stmCov = Utils.round(stmCovData.getVisited() * 1.0f / stmCovData.getTotal() * 100, 4);
                    msg = EnviroCoverageTypeNode.STATEMENT + " cov: " + stmCov + "%; ";

                    // branch cov
                    CoverageDataObject branchCovData = AbstractCoverageManager
                            .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.BRANCH);
                    double branchCov = Utils.round(branchCovData.getVisited() * 1.0f / branchCovData.getTotal() * 100, 4);
                    msg += EnviroCoverageTypeNode.BRANCH + " cov: " + branchCov + "%";

                    TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                    executionDataNode.setCoverage(msg);
                    break;
                }
                case EnviroCoverageTypeNode.STATEMENT_AND_MCDC: {
                    String msg = "";
                    // stm coverage
                    CoverageDataObject stmCovData = AbstractCoverageManager
                            .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.STATEMENT);
                    double stmCov = Utils.round(stmCovData.getVisited() * 1.0f / stmCovData.getTotal() * 100, 4);
                    msg = EnviroCoverageTypeNode.STATEMENT + " cov: " + stmCov + "%; ";

                    // mcdc coverage
                    CoverageDataObject branchCovData = AbstractCoverageManager
                            .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.MCDC);
                    double mcdcCov = Utils.round(branchCovData.getVisited() * 1.0f / branchCovData.getTotal() * 100, 4);
                    msg += EnviroCoverageTypeNode.MCDC + " cov: " + mcdcCov + "%";

                    TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                    executionDataNode.setCoverage(msg);
                    break;
                }
            }

            // display on Execution View
            TestCasesExecutionTabController testCasesExecutionTabController = TCExecutionDetailLogger.getTCExecTabControllerByFunction(functionNode);
            if (testCasesExecutionTabController != null) {
                ObservableList<TestCaseExecutionDataNode> data = testCasesExecutionTabController.getData();
                executionDataNode.setId(data.size());
                data.add(executionDataNode);
            }

            testCase.setStatus(TestCase.STATUS_SUCCESS);
            // update testcase on disk
            TestCaseManager.exportBasicTestCaseToFile(testCase);
            // export coverage of testcase to file
            AbstractCoverageManager.exportCoveragesOfTestCaseToFile(testCase, Environment.getInstance().getTypeofCoverage());
            // save to tst file and navigator tree
//            testCase.updateToTestCasesNavigatorTree();
            refreshNavigatorTree();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            execTasks.remove(this);
            String strategy = testCase.getFunctionNode().getFunctionConfig().getTestdataGenStrategy();
            if (strategy.equals(IFunctionConfig.TEST_DATA_GENERATION_STRATEGIES.RANDOM)) {
                // stop condition for RANDOM test data generation strategy
                TestCasesTreeItem treeItem = CacheHelper.getFunctionToTreeItemMap().get(testCase.getFunctionNode());
                // get test cases that have just be generated
                List<TestCase> testCases = CacheHelper.getTreeItemToListTestCasesMap().get(treeItem);
                long generated = testCases.size();
                long maxIteration = getFunctionNode().getFunctionConfig().getTheMaximumNumberOfIterations();
                if (generated == maxIteration && execTasks.isEmpty()) { // test data RANDOM auto generating stage is done
                    // view coverage of generated set of test cases
                    try {
                        UIController.viewCoverageOfMultipleTestcasesFromAnotherThread(functionNode.getName(), testCases);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }
        }

//        done();
        System.out.println("Thread " +Thread.currentThread().getName()+ " is DONE");
        System.out.println("Thread " +Thread.currentThread().getName() +" is -" + this.isRunning());

        // remove
//        for (AkaThread thread: AkaThreadManager.getTotalRunningThreads())
//            if (thread.getTask().equals(this))
//            {
//                AkaThreadManager.akaThreadList.remove(thread);
//                break;
//            }
        return testCase;
    }

    private void refreshNavigatorTree() {
        Platform.runLater(() -> TestCasesNavigatorController.getInstance().refreshNavigatorTree());
    }

    //    protected void updateCFG() throws Exception {
//        String coverage = Environment.getInstance().getTypeofCoverage();
//        switch (coverage) {
//            case EnviroCoverageTypeNode.MCDC:
//            case EnviroCoverageTypeNode.BRANCH: {
//                String unvisitedBranches = executor.getCfg().getUnvisitedBranches().toString();
//                TCExecutionDetailLogger.logDetailOfTestCase(testCase, "unvisited branches = " + unvisitedBranches);
//
//                // check coverage
////                if (executor.getCfg().getUnvisitedBranches().size() == 0) {
////                    logger.debug("[" + Thread.currentThread().getName()+"] "+ "[" + Thread.currentThread().getName()+"] "+ "Done. Coverage = 100%");
////                    throw new MaximumCoverageException("Done. Coverage = 100%");
////                }
//                break;
//            }
//
//            case EnviroCoverageTypeNode.STATEMENT: {
//                // log unvisited instructions
//                String unvisitedStatements = executor.getCfg().getUnvisitedStatements().toString();
//                TCExecutionDetailLogger.logDetailOfTestCase(testCase, "Unvisited statements = " + unvisitedStatements);
//
//                // check coverage
////                if (executor.getCfg().getUnvisitedStatements().size() == 0) {
////                    logger.debug("[" + Thread.currentThread().getName()+"] "+ "[" + Thread.currentThread().getName()+"] "+ "Done. Statement coverage = 100%.");
////                    throw new MaximumCoverageException("Done. Statement coverage = 100%");
////                }
//                break;
//            }
//            case EnviroCoverageTypeNode.STATEMENT_AND_BRANCH:
//            case EnviroCoverageTypeNode.BASIS_PATH:
//            case EnviroCoverageTypeNode.STATEMENT_AND_MCDC: {
//                TCExecutionDetailLogger.logDetailOfTestCase(testCase, ITestCase.STATUS_NA);
//                break;
//            }
//        }
//
//        // save test case to file
//        testCase.setPath(new WorkspaceConfig().fromJson().getTestcaseDirectory() + File.separator + testCase.getName() + ".json");
//
//        // save data tree to the test script for re-open later
//        TestCaseManager.exportBasicTestCaseToFile(testCase);
//        logger.debug("[" + Thread.currentThread().getName()+"] "+ "Save the testcase " + testCase.getName() + " to file " + testCase.getPath());
//    }


    public ICommonFunctionNode getFunctionNode() {
        return functionNode;
    }

    public void setFunctionNode(ICommonFunctionNode functionNode) {
        this.functionNode = functionNode;
    }

    public String getAdditionalHeaders() {
        return additionalHeaders;
    }

    public void setAdditionalHeaders(String additionalHeaders) {
        this.additionalHeaders = additionalHeaders;
    }
}
