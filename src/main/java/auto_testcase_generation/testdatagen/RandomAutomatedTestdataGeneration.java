package auto_testcase_generation.testdatagen;

import com.dse.config.FunctionConfig;
import com.dse.config.WorkspaceConfig;
import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
import com.dse.guifx_v3.helps.AutoGeneratedTestCaseExecTask;
import com.dse.guifx_v3.helps.CacheHelper;
import com.dse.guifx_v3.helps.GenerateTestdataTask;
import com.dse.guifx_v3.helps.UILogger;
import com.dse.guifx_v3.objects.TestCasesTreeItem;
import com.dse.parser.object.*;
import com.dse.search.Search2;
import com.dse.testcase_manager.*;
import com.dse.testdata.gen.module.SimpleTreeDisplayer;
import com.dse.testdata.object.*;
import com.dse.thread.AkaThread;
import com.dse.thread.AkaThreadManager;
import com.dse.util.AkaLogger;
import com.dse.util.IGTestConstant;
import com.dse.util.Utils;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import javafx.application.Platform;

import java.io.File;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class RandomAutomatedTestdataGeneration extends AbstractAutomatedTestdataGeneration {
    private final static AkaLogger logger = AkaLogger.get(RandomAutomatedTestdataGeneration.class);

    public RandomAutomatedTestdataGeneration(ICommonFunctionNode fn) {
        super(fn);
    }

    public void generateTestdata(ICommonFunctionNode fn) throws Exception {
        logger.debug("[" + Thread.currentThread().getName() + "] " + "Generating test data for function " + fn.getName());
        logger.debug("[" + Thread.currentThread().getName() + "] " + "Automated test data generation strategy: random");

        if (fn.getFunctionConfig() == null) {
            FunctionConfig functionConfig = new WorkspaceConfig().fromJson().getDefaultFunctionConfig();
            functionConfig.setFunctionNode(fn);
            fn.setFunctionConfig(functionConfig);
            functionConfig.createBoundOfArgument(functionConfig, fn);
        }

        final long MAX_ITERATON = fn.getFunctionConfig().getTheMaximumNumberOfIterations(); // may change to any value
        logger.debug("[" + Thread.currentThread().getName()+"] "+"[" + Thread.currentThread().getName() + "] " + "Maximum number of iterations = " + MAX_ITERATON);

        // clear cache before generate testcase
        TestCasesTreeItem treeItem = CacheHelper.getFunctionToTreeItemMap().get(fn);
        if (CacheHelper.getTreeItemToListTestCasesMap().get(treeItem) != null)
            CacheHelper.getTreeItemToListTestCasesMap().get(treeItem).clear();

        //
        if (fn.isTemplate() || fn instanceof MacroFunctionNode) {
            if (this.allPrototypes == null || this.allPrototypes.size() == 0)
                this.allPrototypes = getAllPrototypesOfTemplateFunction(fn);
            if (this.allPrototypes == null || this.allPrototypes.size() == 0)
                return;
            ;
            for (TestCase prototype : allPrototypes)
                start(MAX_ITERATON, prototype);
        } else {
            start(MAX_ITERATON, null);
        }

//        Platform.runLater(new Runnable() {
//            @Override
//            public void run() {
////                while (true) {
//                List<TestCase> testCases = new ArrayList<>();
//
//                while (!execTasks.isEmpty()) {
//                    try {
//                        Thread.sleep(100);
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
////                    System.out.println("checking " + execTasks.size());
//                }
//
//                for (AutoGeneratedTestCaseExecTask task : functionExecThread.getTestCaseExecTask()) {
//                    TestCase testCase = task.getTestCase();
//                    testCases.add(testCase);
//                }
//
////                UIController.viewCoverageOfMultipleTestcases("???", testCases);
////                }
//            }
//        });
    }

    /**
     * Generate test data
     *
     * @param MAX_ITERATON
     * @param selectedPrototype a prototype of template function. null if the function is not a template function
     */
    protected void start(final long MAX_ITERATON, TestCase selectedPrototype) {
        fn.getFunctionConfig().setFunctionNode(fn);
        for (int iteration = 0; iteration < MAX_ITERATON; iteration++) {
            logger.debug("[" + Thread.currentThread().getName() + "] " + "Iteration " + (iteration + 1) + "/" + MAX_ITERATON);
            TestcaseExecution executor = new TestcaseExecution();
            executor.setFunction(fn);
            executor.setMode(TestcaseExecution.IN_AUTOMATED_TESTDATA_GENERATION_MODE);

            boolean isMaximizedCoverage = iterate(iteration, executor, fn, selectedPrototype);
            if (isMaximizedCoverage)
                break;
        }
        logger.debug("[" + Thread.currentThread().getName() + "] " + "Done automated test data generation");
    }

    protected boolean iterate(int iteration, TestcaseExecution executor, ICommonFunctionNode fn, TestCase selectedPrototype) {
        boolean isMaximizedCoverage = false;

        // create a new test case at each iteration
        int seed = new Random().nextInt(9999999);
        String nameofTestcase = AbstractTestCase.removeSpecialCharacter(fn.getSimpleName() + ITestCase.AKA_SIGNAL + seed); // to create unique name temporarily

        TestCase testCase = null;
        if (fn.isTemplate() || fn instanceof MacroFunctionNode) {
            String content = Utils.readFileContent(new File(selectedPrototype.getPath()));
            String newName = nameofTestcase;
            content = content.replace(selectedPrototype.getName(), nameofTestcase);
            String newFile = new File(selectedPrototype.getPath()).getParent() + File.separator + newName + ".json";
            Utils.writeContentToFile(content, newFile);
            testCase = TestCaseManager.getBasicTestCaseByName(nameofTestcase, new WorkspaceConfig().fromJson().getTestcaseDirectory()
                    , true);
            TestCaseManager.nameToBasicTestCaseMap.put(newName, testCase);
            logger.debug("Load prototype " + selectedPrototype.getPath());
            logger.debug("Create new test case from prototype: " + newFile);
        } else
            testCase = TestCaseManager.createTestCase(nameofTestcase, fn);

        if (testCase == null)
            return false;
        try {
            testCase.setCreationDateTime(LocalDateTime.now());
            String tpFile = fn.getSimpleName()
                    .replace(File.separator, "___")// to avoid the misunderstanding between system separator and its name
                    + ITestCase.AKA_SIGNAL + seed + "_iter_" + iteration;
            testCase.setTestPathFile(new WorkspaceConfig().fromJson().getTestpathDirectory() + File.separator + tpFile + ".tp");
            ICommonFunctionNode sut = testCase.getFunctionNode();
//            if (!(sut instanceof IFunctionNode))
//                return false;

            RootDataNode root = testCase.getRootDataNode();

            List<String> additionalHeaders = new ArrayList<>();
            // generate random value for parameters
            if (!(sut instanceof ConstructorNode)) {
                logger.debug("[" + Thread.currentThread().getName() + "] " + "Generate random value for new test case");
                List<RandomValue> randomValuesForArguments = generateRandomValueForArguments(root, sut, additionalHeaders, selectedPrototype);
                logger.debug("randomValuesForArguments: " + randomValuesForArguments);
            }

            // generate random value for instance
            List<RandomValue> randomValuesForInstance = generateRandomValuesForInstance(root, sut, additionalHeaders);
            logger.debug("randomValuesForInstance = " + randomValuesForInstance);

            // generate random value for global variables
            List<RandomValue> randomValuesForGlobalVariables = generateRandomValuesForGlobal(root, sut, additionalHeaders);
            logger.debug("randomValuesForGlobalVariables = " + randomValuesForGlobalVariables);

            try {
                logger.debug(new SimpleTreeDisplayer().toString(root));
            } catch (Exception e) {
                e.printStackTrace();
            }

            //
            String additionalHeadersAll = "";
            for (String item : additionalHeaders)
                additionalHeadersAll += item;

            // add to navigator tree
            testCase.updateToTestCasesNavigatorTree();
            Platform.runLater(() -> TestCasesNavigatorController.getInstance().refreshNavigatorTree());

            // start
            AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(iteration, executor, testCase, execTasks);
            task.setAdditionalHeaders(additionalHeadersAll);
            AkaThread thread = new AkaThread(task);
            thread.setName(getFunctionExecThread().getFunction().getSimpleName() + "(iteration " + iteration + ")");
            UILogger.getUiLogger().info("Executing test case: " + testCase);
            AkaThreadManager.autoTestdataGenForFunctionThreadPool.execute(thread);
            AkaThreadManager.akaThreadList.add(thread);
            functionExecThread.getTestCaseExecTask().add(task);
            execTasks.add(task);
            outputs.add(testCase);

        } catch (MaximumCoverageException e) {
            isMaximizedCoverage = true;
            logger.debug("[" + Thread.currentThread().getName() + "] " + "Code coverage has achieved 100%. Terminated!");

        } catch (InterruptedException e) {
            isMaximizedCoverage = false;
            testCase.setStatus(TestCase.STATUS_FAILED);
            outputs.remove(testCase);
            e.printStackTrace();
            logger.debug("[" + Thread.currentThread().getName() + "] " + "The thread " + Thread.currentThread().getName() + " is interrupted");

        } catch (Exception e) {
            e.printStackTrace();
            outputs.remove(testCase);
            testCase.setStatus(TestCase.STATUS_FAILED);
            isMaximizedCoverage = false;
            logger.debug("[" + Thread.currentThread().getName() + "] " + "There is a problem with the current test case. Move to the next iteration.");
        }

        return isMaximizedCoverage;
    }
}
