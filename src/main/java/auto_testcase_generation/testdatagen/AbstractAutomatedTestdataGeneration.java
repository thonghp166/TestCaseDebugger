package auto_testcase_generation.testdatagen;

import com.dse.config.WorkspaceConfig;
import com.dse.guifx_v3.helps.AutoGeneratedTestCaseExecTask;
import com.dse.guifx_v3.helps.GenerateTestdataTask;
import com.dse.parser.object.*;
import com.dse.search.Search2;
import com.dse.testcase_manager.PrototypeOfFunction;
import com.dse.testcase_manager.TestCase;
import com.dse.testcase_manager.TestCaseManager;
import com.dse.testdata.InputCellHandler;
import com.dse.testdata.object.*;
import com.dse.util.AkaLogger;
import com.dse.util.IGTestConstant;
import com.dse.util.Utils;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.util.*;
import java.util.concurrent.Callable;

/**
 * Automated test data generation
 */
public abstract class AbstractAutomatedTestdataGeneration implements IAutomatedTestdataGeneration {
    final static AkaLogger logger = AkaLogger.get(AbstractAutomatedTestdataGeneration.class);

    protected GenerateTestdataTask functionExecThread;

    // When we test a function of a class, we need to construct a specified constructor
    protected IFunctionNode selectedConstructor;

    // each prototype is a test case (just define the template type of template function)
    protected List<TestCase> allPrototypes = new ArrayList<>();


    protected List<TestCase> outputs = new ArrayList<>();

    protected List<Callable<Object>> tasks = new ArrayList<>();

    protected List<TestCase> testCases = new ArrayList<>();

    protected List<AutoGeneratedTestCaseExecTask> execTasks = new ArrayList<>();

    protected String coverageType;
    protected boolean maximizeCov = false;

    // store the template type to real type in template function, e.g, "T"->"int"
    // key: template type
    // value: real type
    protected Map<String, String> realTypeMapping;


    // Number of using solver
    public static int numOfSolverCalls = 0;
    // Number of symbolic execution
    public static int numOfSymbolicExecutions = 0;
    // Number of symbolic statements. In each symbolic execution, some of
    // statements will be symbolic.
    public static int numOfSymbolicStatements = 0;
    // Number of execution
    public static int numOfExecutions = 0;
    // Number of solver calls but its solution does not increase coverage
    public static int numOfNotChangeToCoverage = 0;
    // Number of solver calls but can not solve (cause errors)
    public static int numOfSolverCallsbutCannotSolve = 0;
    // The total time of running make command (ms)
    public static long makeCommandRunningTime = 0;
    // The number of running make command
    public static int makeCommandRunningNumber = 0;
    // The total time of execution time (ms)
    public static long executionTime = 0;
    // The total time of waiting solver to get solution (ms)
    public static long solverRunningTime = 0;
    // The total time of generating test data (ms)
    public static long totalRunningTime;
    // The total time of normalizing function (ms)
    public static long normalizationTime;
    // The total time of symbolic execution (ms)
    public static long symbolicExecutionTime;
    // The total time of macro normalization (ms)
    public static long macroNormalizationTime;
    // Bugs detected while executing the program
    public static Set<Bug> bugs = new HashSet<>();
    // Testdata
    public static List<TestdataInReport> testdata = new ArrayList<>();
    // Code coverage
    public static float branchCoverage = 0.0f;
    public static float statementCoverage = 0.0f;

    public static boolean isTerminateDuetoTooLong = false;

    // DOES NOT RESET THESE FOLLOWING FIELDS (FOR SUMMARY PURPOSE)
    public static int numOfBranches = 0;// OVERALL SCOPE
    public static int numOfVisitedBranches = 0;// OVERALL SCOPE
    public static int totalSolverCalls = 0;// OVERALL SCOPE
    public static int totalNumOfExecution = 0;// OVERALL SCOPE
    public static int totalSymbolicStatements = 0;// OVERALL SCOPE
    // item = {iteration, visited branches}
    public static List<Integer[]> visitedBranchesInfor = new ArrayList<>();// OVERALL
    // SCOPE
    public static int tmp_iterations = 0;// OVERALL SCOPE
    public static int currentNumOfVisitedBranches = 0;// OVERALL SCOPE

    public static int removedConstraints = 0; // OVERALL SCOPE
    public static int removedTestdata = 0;// OVERALL SCOPE

    protected ICommonFunctionNode fn;

    public AbstractAutomatedTestdataGeneration(ICommonFunctionNode fn) {
        this.fn = fn;

        numOfSolverCalls = 0;
        numOfSymbolicExecutions = 0;
        numOfSymbolicStatements = 0;
        numOfExecutions = 0;
        numOfSolverCallsbutCannotSolve = 0;
        makeCommandRunningTime = 0;
        makeCommandRunningNumber = 0;
        solverRunningTime = 0;
        totalRunningTime = 0;
        executionTime = 0;
        normalizationTime = 0;
        symbolicExecutionTime = 0;
        macroNormalizationTime = 0;
        bugs = new HashSet<>();
        testdata = new ArrayList<>();
        branchCoverage = 0f;
        statementCoverage = 0f;
        isTerminateDuetoTooLong = false;
    }

//	protected void generateTestdata(IFunctionNode originalFunction) throws Exception {
//		Date startTime = Calendar.getInstance().getTime();
//
//		String strategy = originalFunction.getFunctionConfig().getTestdataGenStrategy();
//		switch (strategy) {
//			case IFunctionConfig.TEST_DATA_GENERATION_STRATEGIES.RANDOM:
//				new RandomAutomatedTestdataGeneration(originalFunction).generate(originalFunction);
//				break;
//			case IFunctionConfig.TEST_DATA_GENERATION_STRATEGIES.DART:
//				new DartAutomatedTestdataGeneration(originalFunction).generate(originalFunction);
//				break;
//			case IFunctionConfig.TEST_DATA_GENERATION_STRATEGIES.SDART:
//				new SdartAutomatedTestdataGeneration(originalFunction).generate(originalFunction);
//				break;
//			default:
//				throw new Exception("The path selection strategy " + strategy + " does not exist!");
//		}
//
//		// Calculate the running time
//		Date end = Calendar.getInstance().getTime();
//		long runningTime = end.getTime() - startTime.getTime();
//		runningTime = runningTime / 1000;// seconds
//
//		UILogger.getUiLogger().logToBothUIAndTerminal("The total time to generate test data automatically = "
//				+ runningTime + " seconds");
//		logger.debug("Generate test data done");
//		logger.debug("\n\n\n\n\n\n\n\n\n\n");
//	}

    public void recursiveExpandUutBranch(IDataNode node, List<RandomValue> values) throws Exception {
        logger.debug("recursiveExpandUutBranch with \"" + node.getName() +"\"");
        // STEP 1: set & get virtual name of current node
        node.setVirtualName();
        String vituralNameOfNode = RandomValue.convertNameUsedInExpansionToCode(node.getVituralName());

        // STEP 2: get raw value from static solutions
        String value = null;
        for (RandomValue randomValue : values)
            if (randomValue.getNameUsedToUpdateValue().equals(vituralNameOfNode)) {
                value = randomValue.getValue();
                break;
            }

        // STEP 3: commit edit with value
        if (value != null) {
            if (node instanceof VoidPointerDataNode) {
                // nothing to do
            } else if (node instanceof OtherUnresolvedDataNode) {
                // nothing to do
            } else if (node instanceof ArrayDataNode || node instanceof PointerDataNode || node instanceof NormalStringDataNode) {
                // Ex: key = "p", value="sizeof(p)=1"
                // get the size of array
                value = value.substring(value.indexOf('=') + 1);
            } else if (node instanceof ClassDataNode && !(node instanceof SubClassDataNode)) {
                // Ex: key = "sv", value="Student(int,int)"
                // get name of the constructor
                if (value.contains("("))
                    value = value.substring(0, value.indexOf('('));
                if (value.contains("::"))
                    value = value.substring(value.indexOf("::") + 2).trim();
            } else if (node instanceof NormalCharacterDataNode) {
                value = NormalCharacterDataNode.toASCII(value) + "";
            }

            if (node instanceof ValueDataNode)
                try {
                    logger.debug("Commit edit for node \"" + node.getName() + "\"; value = \"" + value + "\", class = " + node.getClass().getSimpleName());
                    new InputCellHandler(realTypeMapping).commitEdit((ValueDataNode) node, value);
                } catch (Exception e) {
                    e.printStackTrace();
                }
        }

        // STEP 4: repeat with its children
        for (IDataNode child : node.getChildren())
            recursiveExpandUutBranch(child, values);
    }

    /**
     * The data tree is expanded automatically while generating randomly
     *
     * @param root the root of data tree
     * @param sut  a function
     * @return
     * @throws Exception
     */
    protected List<RandomValue> generateRandomValueForArguments(RootDataNode root, ICommonFunctionNode sut,
                                                              List<String> additionalHeaders,
                                                              TestCase selectedPrototype) throws Exception {
        List<RandomValue> values;
        RandomInputGeneration random = new RandomInputGeneration();
        random.setFunctionNode(sut);
        random.setRoot(root);
        random.setSelectedPrototype(selectedPrototype);
        values = random.constructRandomInput(sut.getArguments(), sut.getFunctionConfig(), "");

        // get mapping between template type and real type
        SubprogramNode subprogramNode = Search2.findSubprogramUnderTest(root);
        if (subprogramNode instanceof TemplateSubprogramDataNode) {
            this.realTypeMapping = ((TemplateSubprogramDataNode) subprogramNode).getRealTypeMapping();
        } else if (subprogramNode instanceof MacroSubprogramDataNode) {
            this.realTypeMapping = ((MacroSubprogramDataNode) subprogramNode).getRealTypeMapping();
        }

        IDataNode sutRoot = Search2.findSubprogramUnderTest(root);
        recursiveExpandUutBranch(sutRoot, values);
        additionalHeaders.add(random.getAdditionalHeader());
        return values;
    }

    /**
     * Create the instance of a class to execute a function in that class
     * <p>
     * The data tree is expanded automatically while generating randomly
     *
     * @param root the root of data tree
     * @param sut  a function
     * @return a random instance
     * @throws Exception
     */
    protected List<RandomValue> generateRandomValuesForInstance(RootDataNode root, ICommonFunctionNode sut, List<String> additionalHeaders) {
        List<RandomValue> values = null;
        try {
            RootDataNode globalRoot = Search2.findGlobalRoot(root);

            // find the class where the function is put in
            // if the function is not in a class, we get its source code file
            INode classNode = null;
            if (sut instanceof IFunctionNode)
                classNode = ((IFunctionNode) sut).getRealParent();
            else
                classNode = sut.getParent();

            if (classNode == null || !(classNode instanceof ClassNode))
                // the function is not in a class
                return null;

            ClassDataNode candidateClass = null;
            for (IDataNode child : globalRoot.getChildren())
                if (child instanceof ClassDataNode)
                    // if the global node is corresponding to an instance
                    if (child.getName().startsWith(IGTestConstant.INSTANCE_VARIABLE))
                        if (((ClassDataNode) child).getCorrespondingType().getAbsolutePath().equals(classNode.getAbsolutePath())) {
                            candidateClass = (ClassDataNode) child;
                        }

            // select a random instance
            if (candidateClass == null)
                return null;

            // initialize the instance
            TmpVariableNode variableNode = new TmpVariableNode();
            variableNode.setRawType(candidateClass.getType());
            variableNode.setCoreType(candidateClass.getType());
            variableNode.setReducedRawType(candidateClass.getType());
            variableNode.setName(candidateClass.getName());
            variableNode.setCorrespondingNode(candidateClass.getCorrespondingType());
            variableNode.setParent(fn);

            List<IVariableNode> vars = new ArrayList<>();
            vars.add(variableNode);

            // update the data tree and generate random values for arguments in the created instance
            RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
            randomInputGeneration.setFunctionNode(sut);
            if (fn instanceof ConstructorNode)
                randomInputGeneration.setSelectedConstructor((ConstructorNode) fn);
            values = randomInputGeneration.constructRandomInput(vars, sut.getFunctionConfig(), "");
            recursiveExpandUutBranch(candidateClass, values);
            additionalHeaders.add(randomInputGeneration.getAdditionalHeader());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return values;
    }

    protected List<RandomValue> generateRandomValuesForGlobal(RootDataNode root, ICommonFunctionNode sut, List<String> additionalHeaders) {
        List<RandomValue> values = null;
        try {
            RootDataNode globalRoot = Search2.findGlobalRoot(root);

            List<ValueDataNode> globalDataNodes = new ArrayList<>();
            for (IDataNode child : globalRoot.getChildren())
                // not the instance
                if (!(child.getName().startsWith(IGTestConstant.INSTANCE_VARIABLE)))
                    if (child instanceof ValueDataNode) {
                        globalDataNodes.add((ValueDataNode) child);
                    }

            logger.debug("Num of global data nodes = " + globalDataNodes);

            for (ValueDataNode globalDataNode : globalDataNodes) {
                List<IVariableNode> vars = new ArrayList<>();
                vars.add(globalDataNode.getCorrespondingVar());

                // update the data tree and generate random values for arguments in the created instance
                RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
                randomInputGeneration.setFunctionNode((IFunctionNode) sut);

                // Ex: "Algorithm::Utils::a", name var = "Utils::a" --> prefix = "Algorithm::"
                String prefixName = globalDataNode.getVituralName();
                prefixName = prefixName.replaceAll(globalDataNode.getName() + "\\s*$", "");

                values = randomInputGeneration.constructRandomInput(vars, ((IFunctionNode) sut).getFunctionConfig(), prefixName);
                recursiveExpandUutBranch(globalDataNode, values);
                additionalHeaders.add(randomInputGeneration.getAdditionalHeader());
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return values;
    }

    public static List<TestCase> getAllPrototypesOfTemplateFunction(ICommonFunctionNode fn) {
        List<TestCase> allPrototypes = new ArrayList<>();
        GsonBuilder gsonBuilder = new GsonBuilder();
        Gson customGson = gsonBuilder.create();
        String prototypeFile = Utils.readFileContent(fn.getTemplateFilePath());
        PrototypeOfFunction prototypeOfFunction = customGson.fromJson(prototypeFile, PrototypeOfFunction.class);
        List<String> prototypes = prototypeOfFunction.getPrototypes();

        for (String prototype : prototypes) {
            TestCase selectedPrototype = TestCaseManager.getBasicTestCaseByName(
                    new File(prototype).getName().replace(".json", ""),
                    new WorkspaceConfig().fromJson().getTestcaseDirectory(), true);
            allPrototypes.add(selectedPrototype);
        }
        return allPrototypes;
    }

    public GenerateTestdataTask getFunctionExecThread() {
        if (functionExecThread == null) {
            this.functionExecThread = new GenerateTestdataTask();
            this.functionExecThread.setFunction(this.fn);
        }
        return functionExecThread;
    }

    public void setFunctionExecThread(GenerateTestdataTask functionExecThread) {
        this.functionExecThread = functionExecThread;
    }

    public List<TestCase> getAllPrototypes() {
        return allPrototypes;
    }

    public void setAllPrototypes(List<TestCase> allPrototypes) {
        this.allPrototypes = allPrototypes;
    }

    public IFunctionNode getSelectedConstructor() {
        return selectedConstructor;
    }

    public void setSelectedConstructor(IFunctionNode selectedConstructor) {
        this.selectedConstructor = selectedConstructor;
    }

    public List<TestCase> getOutputs() {
        return outputs;
    }
}
