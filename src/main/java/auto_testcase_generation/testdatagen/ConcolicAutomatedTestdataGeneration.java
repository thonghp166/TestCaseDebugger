//package auto_testcase_generation.testdatagen;
//
//import auto_testcase_generation.cfg.ICFG;
//import auto_testcase_generation.cfg.object.ConditionCfgNode;
//import auto_testcase_generation.cfg.object.ICfgNode;
//import auto_testcase_generation.cfg.testpath.StaticSolutionGeneration;
//import auto_testcase_generation.testdatagen.se.ISymbolicExecution;
//import auto_testcase_generation.testdatagen.se.Parameter;
//import auto_testcase_generation.testdatagen.se.PathConstraints;
//import auto_testcase_generation.testdatagen.se.SymbolicExecution;
//import auto_testcase_generation.testdatagen.se.solver.SmtLibGeneration;
//import auto_testcase_generation.testdatagen.testdatainit.BasicTypeRandom;
//import com.dse.config.AkaConfig;
//import com.dse.config.FunctionConfig;
//import com.dse.config.WorkspaceConfig;
//import com.dse.coverage.SourcecodeCoverageComputation;
//import com.dse.environment.object.EnviroCoverageTypeNode;
//import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
//import com.dse.guifx_v3.helps.AutoGeneratedTestCaseExecTask;
//import com.dse.guifx_v3.helps.CacheHelper;
//import com.dse.guifx_v3.helps.Environment;
//import com.dse.guifx_v3.helps.GenerateTestdataTask;
//import com.dse.guifx_v3.objects.TestCasesTreeItem;
//import com.dse.parser.object.*;
//import com.dse.search.Search2;
//import com.dse.testcase_manager.ITestCase;
//import com.dse.testcase_manager.PrototypeOfFunction;
//import com.dse.testcase_manager.TestCase;
//import com.dse.testcase_manager.TestCaseManager;
//import com.dse.testcasescript.TestcaseSearch;
//import com.dse.testcasescript.object.ITestcaseNode;
//import com.dse.testcasescript.object.TestNormalSubprogramNode;
//import com.dse.testcasescript.object.TestcaseRootNode;
//import com.dse.testdata.InputCellHandler;
//import com.dse.testdata.gen.module.SimpleTreeDisplayer;
//import com.dse.testdata.object.*;
//import com.dse.thread.AkaThread;
//import com.dse.thread.AkaThreadManager;
//import com.dse.util.AkaLogger;
//import com.dse.util.IGTestConstant;
//import com.dse.util.Utils;
//import com.google.gson.Gson;
//import com.google.gson.GsonBuilder;
//import org.apache.commons.math3.random.RandomDataGenerator;
//import org.jgrapht.Graph;
//import org.jgrapht.alg.interfaces.ShortestPathAlgorithm;
//import org.jgrapht.alg.shortestpath.DijkstraShortestPath;
//import org.jgrapht.graph.DefaultDirectedGraph;
//import org.jgrapht.graph.DefaultEdge;
//import org.junit.Test;
//
//import java.io.File;
//import java.time.LocalDateTime;
//import java.util.*;
//import java.util.concurrent.Callable;
//import java.util.concurrent.Executors;
//
//public class ConcolicAutomatedTestdataGeneration extends AbstractAutomatedTestdataGeneration {
//    private final static AkaLogger logger = AkaLogger.get(ConcolicAutomatedTestdataGeneration.class);
//    private GenerateTestdataTask functionExecThread;
//
//    // store the template type to real type in template function, e.g, "T"->"int"
//    // key: template type
//    // value: real type
//    private Map<String, String> realTypeMapping;
//
//    // When we test a function of a class, we need to construct a specified constructor
//    private IFunctionNode selectedConstructor;
//
//    // each prototype is a test case (just define the template type of template function)
//    private List<TestCase> allPrototypes = new ArrayList<>();
//
//
//    private List<TestCase> outputs = new ArrayList<>();
//
//    private List<Callable<Object>> tasks = new ArrayList<>();
//
//    private List<TestCase> testCases = new ArrayList<>();
//
//    public ConcolicAutomatedTestdataGeneration(ICommonFunctionNode fn) {
//        super(fn);
//    }
//
//    private int previousNumberOfVisitedInstruments = 0;
//
//    public void generateTestdata(ICommonFunctionNode fn) throws Exception {
//        logger.debug("[" + Thread.currentThread().getName() + "] " + "Generating test data for function " + fn.getName());
//        logger.debug("[" + Thread.currentThread().getName() + "] " + "Automated test data generation strategy: random");
//
//        if (fn.getFunctionConfig() == null) {
//            FunctionConfig functionConfig = new WorkspaceConfig().fromJson().getDefaultFunctionConfig();
//            functionConfig.setFunctionNode(fn);
//            fn.setFunctionConfig(functionConfig);
//            functionConfig.createBoundOfArgument(functionConfig, fn);
//        }
//
//        final long MAX_ITERATON = fn.getFunctionConfig().getTheMaximumNumberOfIterations(); // may change to any value
//        logger.debug("[" + Thread.currentThread().getName() + "] " + "Maximum number of iterations = " + MAX_ITERATON);
//
//        // clear cache before generate testcase
//        TestCasesTreeItem treeItem = CacheHelper.getFunctionToTreeItemMap().get(fn);
//        if (CacheHelper.getTreeItemToListTestCasesMap().get(treeItem) != null)
//            CacheHelper.getTreeItemToListTestCasesMap().get(treeItem).clear();
//
//        //
//        if (fn.isTemplate() || fn instanceof MacroFunctionNode) {
//            if (this.allPrototypes == null || this.allPrototypes.size() == 0)
//                this.allPrototypes = getAllPrototypesOfTemplateFunction(fn);
//            if (this.allPrototypes == null || this.allPrototypes.size() == 0)
//                return;
//
//            for (TestCase prototype : allPrototypes)
////                start(MAX_ITERATON, prototype);
//                start();
//        } else {
////            start(MAX_ITERATON, null);
//            start();
//        }
//    }
//
//    /**
//     * Generate test data
//     */
//    protected void start() {
//        this.testCases = findAllExistingTestcase(this.fn);
//        int MAX_TESTCASES = 1;
//        for (int i = 0; i < MAX_TESTCASES; i++) {
//            boolean maxiCov = generateDirectly(this.testCases, this.fn, EnviroCoverageTypeNode.STATEMENT);
//            TestCasesNavigatorController.getInstance().refreshNavigatorTree();
//            if (maxiCov)
//                break;
//        }
//    }
//
//    /**
//     * @param functionNode
//     * @return all test cases of the given function
//     */
//    public List<TestCase> findAllExistingTestcase(ICommonFunctionNode functionNode) {
//        List<TestCase> testCases = new ArrayList<>();
//
//        TestNormalSubprogramNode selectedSubprogam = null;
//        TestcaseRootNode testcaseRoot = Environment.getInstance().getTestcaseScriptRootNode();
//        List<ITestcaseNode> subprograms = TestcaseSearch.searchNode(testcaseRoot, new TestNormalSubprogramNode());
//        for (ITestcaseNode subprogram : subprograms)
//            if (subprogram instanceof TestNormalSubprogramNode)
//                if (((TestNormalSubprogramNode) subprogram).getName()
//                        .equals(functionNode.getAbsolutePath())) {
//                    selectedSubprogam = (TestNormalSubprogramNode) subprogram;
//                    break;
//                }
//
//        if (selectedSubprogam != null) {
//            List<String> testcasesList = selectedSubprogam.getAllTestCases();
//            for (String tc : testcasesList) {
//                TestCase t = TestCaseManager.getBasicTestCaseByName(tc);
//                if (t != null) {
//                    testCases.add(t);
//                }
//            }
//        }
//        return testCases;
//    }
//
//    public boolean generateDirectly(List<TestCase> testCases, ICommonFunctionNode functionNode, String cov) {
//        logger.debug("Size of test cases = " + testCases.size());
//        String allTestpaths = "";
//        for (TestCase testCase : testCases)
//            if (testCase.getTestPathFile() != null && new File(testCase.getTestPathFile()).exists())
//                allTestpaths += Utils.readFileContent(testCase.getTestPathFile()) + "\n";
//
//        // coverage
//        ICFG currentCFG = null;
//        if (allTestpaths.length() > 0) {
//            ISourcecodeFileNode sourcecodeNode = Utils.getSourcecodeFile(functionNode);
//            SourcecodeCoverageComputation sourcecodeCoverageComputation = new SourcecodeCoverageComputation();
//            sourcecodeCoverageComputation.setCoverage(cov);
//            sourcecodeCoverageComputation.setConsideredSourcecodeNode(sourcecodeNode);
//            sourcecodeCoverageComputation.setTestpathContent(allTestpaths);
//            sourcecodeCoverageComputation.compute();
//
//            List<ICFG> CFGs = sourcecodeCoverageComputation.getAllCFG();
//            for (ICFG cfg : CFGs) {
//                if (cfg.getFunctionNode().getAbsolutePath().equals(fn.getAbsolutePath())) {
//                    currentCFG = cfg;
//                    break;
//                }
//            }
//        } else {
//            try {
//                if (functionNode instanceof MacroFunctionNode) {
//                    IFunctionNode tmpFunctionNode = ((MacroFunctionNode) functionNode).getCorrespondingFunctionNode();
//                    currentCFG = Utils.createCFG(tmpFunctionNode, cov);
//                    currentCFG.setFunctionNode(tmpFunctionNode);
//                } else if (functionNode instanceof AbstractFunctionNode) {
//                    currentCFG = Utils.createCFG((IFunctionNode) functionNode, cov);
//                    currentCFG.setFunctionNode((IFunctionNode) functionNode);
//                }
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
//
//        if (currentCFG != null) {
//            logger.debug("Visited stm = " + currentCFG.getVisitedStatements().size());
//            int nStm = currentCFG.getVisitedStatements().size() + currentCFG.getUnvisitedStatements().size();
//            logger.debug("Total stm = " + nStm);
//
//            if (currentCFG.getUnvisitedStatements().size() == 0)
//                return true;
//
//            ICfgNode unvisitedStm = null;
//            // for testing - beign
////            for (ICfgNode n : currentCFG.getUnvisitedStatements())
////                if (n.getContent().equals("index = c;")) {
////                    unvisitedStm = n;
////                    break;
////                }
//            // for testing - end
//             unvisitedStm = currentCFG.getUnvisitedStatements().get(
//                    new BasicTypeRandom().generateInt(0, currentCFG.getUnvisitedStatements().size() - 1));
//            logger.debug("Choose unvisited stm \"" + unvisitedStm + "\"");
//
//            // find a shortest test path through unvisited instructions
//            currentCFG.setIdforAllNodes();
//            List<ICfgNode> shortestTestpath = findShortestTestpath(unvisitedStm, currentCFG);
//            logger.debug("Shortest test path: " + shortestTestpath);
//
//            if (shortestTestpath.size() == 0)
//                return false;
//
//            /**
//             * SE
//             */
//            Parameter paramaters = new Parameter();
//            paramaters.addAll(fn.getArguments());
//
//            try {
//                ISymbolicExecution se = new SymbolicExecution(shortestTestpath, paramaters, (IFunctionNode) fn);
//                logger.debug("constraints=\n" + se.getConstraints());
//
//                // smt-lib
//                String constraintFile = new WorkspaceConfig().fromJson().getConstraintFolder()
//                        + File.separator + new RandomDataGenerator().nextInt(0, 9999) + ".smt2";
//                logger.debug("Constraint file: " + constraintFile);
//                PathConstraints constraints = new PathConstraints();
//                constraints.addAll((PathConstraints) se.getConstraints());
//                SmtLibGeneration smt = new SmtLibGeneration(fn.getArguments(), constraints, functionNode);
//                smt.generate();
//                Utils.writeContentToFile(smt.getSmtLibContent(), constraintFile);
//                logger.debug("SMT-Lib: " + smt.getSmtLibContent());
//
//                // solve
//                logger.debug("Calling solver z3");
//                String z3Path = new AkaConfig().fromJson().getZ3Path();
//                if (new File(z3Path).exists()) {
//                    StaticSolutionGeneration solver = new StaticSolutionGeneration();
//                    solver.setConstraintsFile(constraintFile);
//                    solver.setZ3SolverPath(z3Path);
//                    String theNextTestdata = solver.solve(constraints, (IFunctionNode) fn);
//                    logger.debug("the next test data = " + theNextTestdata);
//
//                    // execute
//                    TestcaseExecution executor = new TestcaseExecution();
//                    executor.setFunction(fn);
//                    executor.setMode(TestcaseExecution.IN_AUTOMATED_TESTDATA_GENERATION_MODE);
//                    TestCase testCase = TestCaseManager.createTestCase(
//                            fn.getSimpleName() + ".directed." + new RandomDataGenerator().nextInt(0, 9999), fn);
//                    iterateDirectly(testCase, executor, fn, theNextTestdata);
//
//                    testCases.add(testCase);
//                    return false;
//                } else
//                    throw new Exception("Z3 path " + z3Path + " does not exist");
//
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
////        }
//        return false;
//    }
//
//    protected boolean iterateDirectly(TestCase testCase, TestcaseExecution executor, ICommonFunctionNode fn, String theNextTestdata) {
//        int iteration = 99999;
//        ValueToTestcaseConverter converter = new ValueToTestcaseConverter(theNextTestdata, fn);
//        List<RandomValue> randomValues = new ArrayList<>();
//        randomValues.addAll(converter.findSizeOfPointerandArray(converter.getTestcases()));
//        randomValues.addAll(converter.findValueOfElement(converter.getTestcases()));
//        RootDataNode root = testCase.getRootDataNode();
//
//        // generate random value for instance
//        try {
//            recursiveExpandUutBranch(root.getRoot(), randomValues);
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//
//        try {
//            logger.debug(new SimpleTreeDisplayer().toString(root));
//
//            AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(iteration, executor, testCase);
//            task.setAdditionalHeaders("");
//            AkaThread thread = new AkaThread(task);
//            thread.setName(getFunctionExecThread().getFunction().getSimpleName() + "(iteration " + iteration + ")");
////            AkaThreadManager.autoTestdataGenForFunctionThreadPool.execute(thread);
//            AkaThreadManager.akaThreadList.add(thread);
//            functionExecThread.getTestCaseExecTask().add(task);
//            return true;
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//        return false;
//    }
//
//    public static String toDescription(ICfgNode node) {
//        return String.format("%s(id = %s)", node.getContent(), node.getId());
//    }
//
//    public static List<ICfgNode> findShortestTestpath(ICfgNode target, ICFG currentCFG) {
//        List<ICfgNode> shortestPath = new ArrayList<>();
//        Map<String, ICfgNode> mapping = new HashMap<>();
//
//        Graph<String, DefaultEdge> graph = new DefaultDirectedGraph<>(DefaultEdge.class);
//
//        for (ICfgNode node : currentCFG.getAllNodes()) {
//            String name = toDescription(node);
//            graph.addVertex(name);
//
//            mapping.put(name, node);
//        }
//
//        for (ICfgNode node : currentCFG.getAllNodes()) {
//            if (node.getTrueNode() != null && node.getFalseNode() != null) {
//                if (!node.getTrueNode().equals(node.getFalseNode())) {
//                    graph.addEdge(toDescription(node), toDescription(node.getTrueNode()));
//                    graph.addEdge(toDescription(node), toDescription(node.getFalseNode()));
//                } else
//                    graph.addEdge(toDescription(node), toDescription(node.getFalseNode()));
//            } else if (node.getTrueNode() != null) {
//                graph.addEdge(toDescription(node), toDescription(node.getTrueNode()));
//            } else if (node.getFalseNode() != null) {
//                graph.addEdge(toDescription(node), toDescription(node.getFalseNode()));
//            }
//        }
//
//        // Find shortest paths
//        logger.debug("Shortest path from begin node of CFG to " + target.getContent() + " :");
//        DijkstraShortestPath dijkstraAlg = new DijkstraShortestPath<>(graph);
//        ICfgNode beginNode = currentCFG.getBeginNode();
//        ShortestPathAlgorithm.SingleSourcePaths<String, DefaultEdge> iPaths = dijkstraAlg.getPaths(toDescription(beginNode));
//        org.jgrapht.GraphPath<String, DefaultEdge> shortestTestPath = iPaths.getPath(toDescription(target));
//
//        for (String str : shortestTestPath.getVertexList()) {
//            ICfgNode n = mapping.get(str);
//            shortestPath.add(n);
//        }
//
//        // Normalize path
//        List<ICfgNode> normalizedShortestPath = new ArrayList<>();
//        for (int i = 0; i < shortestPath.size(); i++) {
//            ICfgNode n = shortestPath.get(i);
//            if (n instanceof ConditionCfgNode) {
//                if (i + 1 < shortestPath.size()) {
//                    ICfgNode next = shortestPath.get(i + 1);
//                    if (n.getTrueNode().getId() == next.getId()) {
//                        normalizedShortestPath.add(n);
//                    } else {
//                        ConditionCfgNode clone = new ConditionCfgNode(((ConditionCfgNode) n).getAst()) {
//                            @Override
//                            public boolean isVisitedTrueBranch() {
//                                return super.isVisitedTrueBranch();
//                            }
//                        };
//                        clone.setContent("!(" + n.getContent() + ")");
//                        clone.setAst(Utils.convertToIAST(clone.getContent()));
//                        normalizedShortestPath.add(clone);
//                    }
//                } else {
//
//                }
//            } else {
//                normalizedShortestPath.add(n);
//            }
//        }
//
//        logger.debug("shortestPath = " + shortestPath);
//        logger.debug("normalizedShortestPath = " + normalizedShortestPath);
//        return normalizedShortestPath;
//    }
//
//    public static List<TestCase> getAllPrototypesOfTemplateFunction(ICommonFunctionNode fn) {
//        List<TestCase> allPrototypes = new ArrayList<>();
//        GsonBuilder gsonBuilder = new GsonBuilder();
//        Gson customGson = gsonBuilder.create();
//        String prototypeFile = Utils.readFileContent(fn.getTemplateFilePath());
//        PrototypeOfFunction prototypeOfFunction = customGson.fromJson(prototypeFile, PrototypeOfFunction.class);
//        List<String> prototypes = prototypeOfFunction.getPrototypes();
//
//        for (String prototype : prototypes) {
//            TestCase selectedPrototype = TestCaseManager.getBasicTestCaseByName(
//                    new File(prototype).getName().replace(".json", ""),
//                    new WorkspaceConfig().fromJson().getTestcaseDirectory(), true);
//            allPrototypes.add(selectedPrototype);
//        }
//        return allPrototypes;
//    }
//
//
//    protected TestCase createTestCase(int iteration, ICommonFunctionNode fn, TestCase selectedPrototype) {
//        // create a new test case at each iteration
//        int seed = new Random().nextInt(9999999);
//        String nameofTestcase = fn.getSimpleName() + ITestCase.AKA_SIGNAL + seed; // to create unique name temporarily
//
//        TestCase testCase = null;
//        if (fn.isTemplate() || fn instanceof MacroFunctionNode) {
//            String content = Utils.readFileContent(new File(selectedPrototype.getPath()));
//            String newName = nameofTestcase;
//            content = content.replace(selectedPrototype.getName(), nameofTestcase);
//            String newFile = new File(selectedPrototype.getPath()).getParent() + File.separator + newName + ".json";
//            Utils.writeContentToFile(content, newFile);
//            testCase = TestCaseManager.getBasicTestCaseByName(nameofTestcase, new WorkspaceConfig().fromJson().getTestcaseDirectory()
//                    , true);
//            TestCaseManager.nameToBasicTestCaseMap.put(newName, testCase);
//            logger.debug("Load prototype " + selectedPrototype.getPath());
//            logger.debug("Create new test case from prototype: " + newFile);
//        } else
//            testCase = TestCaseManager.createTestCase(nameofTestcase, fn);
//
//        testCase.setCreationDateTime(LocalDateTime.now());
//        String tpFile = fn.getSimpleName()
//                .replace(File.separator, "___")// to avoid the misunderstanding between system separator and its name
//                + ITestCase.AKA_SIGNAL + seed + "_iter_" + iteration;
//        testCase.setTestPathFile(new WorkspaceConfig().fromJson().getTestpathDirectory() + File.separator + tpFile + ".tp");
//        return testCase;
//    }
//
//    protected boolean iterate(int iteration, TestcaseExecution executor, ICommonFunctionNode fn, TestCase selectedPrototype) {
//        boolean isMaximizedCoverage = false;
//
//        TestCase testCase = createTestCase(iteration, fn, selectedPrototype);
//        if (testCase == null)
//            return false;
//        try {
//            this.testCases.add(testCase);
//
//            ICommonFunctionNode sut = testCase.getFunctionNode();
////            if (!(sut instanceof IFunctionNode))
////                return false;
//
//            RootDataNode root = testCase.getRootDataNode();
//
//            List<String> additionalHeaders = new ArrayList<>();
//            // generate random value for parameters
//            if (!(sut instanceof ConstructorNode)) {
//                logger.debug("[" + Thread.currentThread().getName() + "] " + "Generate random value for new test case");
//                List<RandomValue> randomValuesForArguments = generateRandomValueForArguments(root, sut, additionalHeaders, selectedPrototype);
//                logger.debug("randomValuesForArguments: " + randomValuesForArguments);
//            }
//
//            // generate random value for instance
//            List<RandomValue> randomValuesForInstance = generateRandomValuesForInstance(root, sut, additionalHeaders);
//            logger.debug("randomValuesForInstance = " + randomValuesForInstance);
//
//            // generate random value for global variables
//            List<RandomValue> randomValuesForGlobalVariables = generateRandomValuesForGlobal(root, sut, additionalHeaders);
//            logger.debug("randomValuesForGlobalVariables = " + randomValuesForGlobalVariables);
//
//            try {
//                logger.debug(new SimpleTreeDisplayer().toString(root));
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//
//            //
//            String additionalHeadersAll = "";
//            for (String item : additionalHeaders)
//                additionalHeadersAll += item;
//
//            // start
//            AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(iteration, executor, testCase);
//            task.setAdditionalHeaders(additionalHeadersAll);
//            AkaThread thread = new AkaThread(task);
//            thread.setName(getFunctionExecThread().getFunction().getSimpleName() + "(iteration " + iteration + ")");
////            AkaThreadManager.autoTestdataGenForFunctionThreadPool.execute(thread);
//            AkaThreadManager.akaThreadList.add(thread);
//            functionExecThread.getTestCaseExecTask().add(task);
//
//            //
//            tasks.add(Executors.callable(task));
//
//            outputs.add(testCase);
//
//        } catch (MaximumCoverageException e) {
//            isMaximizedCoverage = true;
//            logger.debug("[" + Thread.currentThread().getName() + "] " + "Code coverage has achieved 100%. Terminated!");
//
//        } catch (InterruptedException e) {
//            isMaximizedCoverage = false;
//            testCase.setStatus(TestCase.STATUS_FAILED);
//            outputs.remove(testCase);
//            e.printStackTrace();
//            logger.debug("[" + Thread.currentThread().getName() + "] " + "The thread " + Thread.currentThread().getName() + " is interrupted");
//
//        } catch (Exception e) {
//            e.printStackTrace();
//            outputs.remove(testCase);
//            testCase.setStatus(TestCase.STATUS_FAILED);
//            isMaximizedCoverage = false;
//            logger.debug("[" + Thread.currentThread().getName() + "] " + "There is a problem with the current test case. Move to the next iteration.");
//        }
//
//        return isMaximizedCoverage;
//    }
//
//    public List<TestCase> getOutputs() {
//        return outputs;
//    }
//
//    /**
//     * The data tree is expanded automatically while generating randomly
//     *
//     * @param root the root of data tree
//     * @param sut  a function
//     * @return
//     * @throws Exception
//     */
//    private List<RandomValue> generateRandomValueForArguments(RootDataNode root, ICommonFunctionNode sut,
//                                                              List<String> additionalHeaders,
//                                                              TestCase selectedPrototype) throws Exception {
//        List<RandomValue> values;
//        RandomInputGeneration random = new RandomInputGeneration();
//        random.setFunctionNode(sut);
//        random.setRoot(root);
//        random.setSelectedPrototype(selectedPrototype);
//        values = random.constructRandomInput(sut.getArguments(), sut.getFunctionConfig(), "");
//
//        // get mapping between template type and real type
//        SubprogramNode subprogramNode = Search2.findSubprogramUnderTest(root);
//        if (subprogramNode instanceof TemplateSubprogramDataNode) {
//            this.realTypeMapping = ((TemplateSubprogramDataNode) subprogramNode).getRealTypeMapping();
//        } else if (subprogramNode instanceof MacroSubprogramDataNode) {
//            this.realTypeMapping = ((MacroSubprogramDataNode) subprogramNode).getRealTypeMapping();
//        }
//
//        IDataNode sutRoot = Search2.findSubprogramUnderTest(root);
//        recursiveExpandUutBranch(sutRoot, values);
//        additionalHeaders.add(random.getAdditionalHeader());
//        return values;
//    }
//
//    private List<RandomValue> generateRandomValuesForGlobal(RootDataNode root, ICommonFunctionNode sut, List<String> additionalHeaders) {
//        List<RandomValue> values = null;
//        try {
//            RootDataNode globalRoot = Search2.findGlobalRoot(root);
//
//            List<ValueDataNode> globalDataNodes = new ArrayList<>();
//            for (IDataNode child : globalRoot.getChildren())
//                // not the instance
//                if (!(child.getName().startsWith(IGTestConstant.INSTANCE_VARIABLE)))
//                    if (child instanceof ValueDataNode) {
//                        globalDataNodes.add((ValueDataNode) child);
//                    }
//
//            logger.debug("Num of global data nodes = " + globalDataNodes);
//
//            for (ValueDataNode globalDataNode : globalDataNodes) {
//                List<IVariableNode> vars = new ArrayList<>();
//                vars.add(globalDataNode.getCorrespondingVar());
//
//                // update the data tree and generate random values for arguments in the created instance
//                RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
//                randomInputGeneration.setFunctionNode((IFunctionNode) sut);
//
//                // Ex: "Algorithm::Utils::a", name var = "Utils::a" --> prefix = "Algorithm::"
//                String prefixName = globalDataNode.getVituralName();
//                prefixName = prefixName.replaceAll(globalDataNode.getName() + "\\s*$", "");
//
//                values = randomInputGeneration.constructRandomInput(vars, ((IFunctionNode) sut).getFunctionConfig(), prefixName);
//                recursiveExpandUutBranch(globalDataNode, values);
//                additionalHeaders.add(randomInputGeneration.getAdditionalHeader());
//            }
//
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//        return values;
//    }
//
//    /**
//     * Create the instance of a class to execute a function in that class
//     * <p>
//     * The data tree is expanded automatically while generating randomly
//     *
//     * @param root the root of data tree
//     * @param sut  a function
//     * @return a random instance
//     * @throws Exception
//     */
//    private List<RandomValue> generateRandomValuesForInstance(RootDataNode root, ICommonFunctionNode sut, List<String> additionalHeaders) {
//        List<RandomValue> values = null;
//        try {
//            RootDataNode globalRoot = Search2.findGlobalRoot(root);
//
//            // find the class where the function is put in
//            // if the function is not in a class, we get its source code file
//            INode classNode = null;
//            if (sut instanceof IFunctionNode)
//                classNode = ((IFunctionNode) sut).getRealParent();
//            else
//                classNode = sut.getParent();
//
//            if (classNode == null || !(classNode instanceof ClassNode))
//                // the function is not in a class
//                return null;
//
//            ClassDataNode candidateClass = null;
//            for (IDataNode child : globalRoot.getChildren())
//                if (child instanceof ClassDataNode)
//                    // if the global node is corresponding to an instance
//                    if (child.getName().startsWith(IGTestConstant.INSTANCE_VARIABLE))
//                        if (((ClassDataNode) child).getCorrespondingType().getAbsolutePath().equals(classNode.getAbsolutePath())) {
//                            candidateClass = (ClassDataNode) child;
//                        }
//
//            // select a random instance
//            if (candidateClass == null)
//                return null;
//
//            // initialize the instance
//            TmpVariableNode variableNode = new TmpVariableNode();
//            variableNode.setRawType(candidateClass.getType());
//            variableNode.setCoreType(candidateClass.getType());
//            variableNode.setReducedRawType(candidateClass.getType());
//            variableNode.setName(candidateClass.getName());
//            variableNode.setCorrespondingNode(candidateClass.getCorrespondingType());
//
//            List<IVariableNode> vars = new ArrayList<>();
//            vars.add(variableNode);
//
//            // update the data tree and generate random values for arguments in the created instance
//            RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
//            randomInputGeneration.setFunctionNode((IFunctionNode) sut);
//            if (fn instanceof ConstructorNode)
//                randomInputGeneration.setSelectedConstructor((ConstructorNode) fn);
//            values = randomInputGeneration.constructRandomInput(vars, ((IFunctionNode) sut).getFunctionConfig(), "");
//            recursiveExpandUutBranch(candidateClass, values);
//            additionalHeaders.add(randomInputGeneration.getAdditionalHeader());
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//        return values;
//    }
//
//    public void recursiveExpandUutBranch(IDataNode node, List<RandomValue> values) throws Exception {
//        // STEP 1: set & get virtual name of current node
//        node.setVirtualName();
//        String vituralNameOfNode = RandomValue.convertNameUsedInExpansionToCode(node.getVituralName());
//
//        // STEP 2: get raw value from static solutions
//        String value = null;
//        for (RandomValue randomValue : values)
//            if (randomValue.getNameUsedToUpdateValue().equals(vituralNameOfNode)) {
//                value = randomValue.getValue();
//                break;
//            }
//
//        // STEP 3: commit edit with value
//        if (value != null) {
//            if (node instanceof UnresolvedDataNode) {
//            } else if (node instanceof ArrayDataNode || node instanceof PointerDataNode || node instanceof NormalStringDataNode) {
//                // Ex: key = "p", value="sizeof(p)=1"
//                // get the size of array
//                value = value.substring(value.indexOf('=') + 1);
//            } else if (node instanceof ClassDataNode && !(node instanceof SubClassDataNode)) {
//                // Ex: key = "sv", value="Student(int,int)"
//                // get name of the constructor
//                if (value.contains("("))
//                    value = value.substring(0, value.indexOf('('));
//                if (value.contains("::"))
//                    value = value.substring(value.indexOf("::") + 2).trim();
//            }
//
//            if (node instanceof NormalCharacterDataNode) {
//                value = NormalCharacterDataNode.toASCII(value) + "";
//            }
//
//            if (node instanceof ValueDataNode)
//                try {
//                    logger.debug("Commit edit for node " + node.getName() + "; value = " + value);
//                    new InputCellHandler(realTypeMapping).commitEdit((ValueDataNode) node, value);
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//        }
//
//        // STEP 4: repeat with its children
//        for (IDataNode child : node.getChildren())
//            recursiveExpandUutBranch(child, values);
//    }
//
//    public GenerateTestdataTask getFunctionExecThread() {
//        if (functionExecThread == null) {
//            this.functionExecThread = new GenerateTestdataTask();
//            this.functionExecThread.setFunction(this.fn);
//        }
//        return functionExecThread;
//    }
//
//    public void setFunctionExecThread(GenerateTestdataTask functionExecThread) {
//        this.functionExecThread = functionExecThread;
//    }
//
//    public List<TestCase> getAllPrototypes() {
//        return allPrototypes;
//    }
//
//    public void setAllPrototypes(List<TestCase> allPrototypes) {
//        this.allPrototypes = allPrototypes;
//    }
//
//    public IFunctionNode getSelectedConstructor() {
//        return selectedConstructor;
//    }
//
//    public void setSelectedConstructor(IFunctionNode selectedConstructor) {
//        this.selectedConstructor = selectedConstructor;
//    }
//}
